---
title: "Exploratory Analysis"
author: "Tessa Senders"
date: "12/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load libraries, warning=FALSE, message=FALSE}
library(tidyverse)
library(stringr)
library(leaps)
```


```{r load data}
hate_crimes_df <- read.csv("./data/HateCrimes.csv") %>%
  janitor::clean_names() %>%
  rename(perc_pop_hs = perc_population_with_high_school_degree) %>% 
  mutate(hate_crimes_per_100k_splc = as.numeric(hate_crimes_per_100k_splc)) %>%
  drop_na(hate_crimes_per_100k_splc) %>%
  mutate(unemployment = as_factor(unemployment),
         urbanization = as_factor(urbanization))
```

4 Missing states (Hawaii, North Dakota, South Dakota, Wyoming)

Percent Non Citizen Maine is missing


```{r descriptive stats}
hate_crimes_df %>%
  ggplot(aes(x = hate_crimes_per_100k_splc)) +
  geom_histogram(aes(y=..density..)) +
  geom_density(alpha=.1, fill="#FF6666") + 
  labs(
    x = "Hate Crimes Per 100k",
    y = "Density",
    caption = "Figure 1: Untransformed distribution of hate crimes per 100k"
  )
```


```{r attempt transformation of outcome}
hate_crimes_df %>%
  mutate(hate_crimes_per_100k_splc = log(hate_crimes_per_100k_splc)) %>%
  ggplot(aes(x = hate_crimes_per_100k_splc)) +
  geom_density()
  
```


Add Box Cox Transformation Here


```{r add log transform}
hate_crimes_df <- hate_crimes_df %>%
  mutate(hate_crimes_log = log(hate_crimes_per_100k_splc))
```

```{r box plot}
hate_crimes_df %>%
  mutate(state = fct_reorder(state, hate_crimes_log)) %>%
ggplot(aes(x = state, y = hate_crimes_log)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 270, vjust = 0.5, hjust=1))
```

DESCRIPTIVE STATISTICS 
Table 1
More boxplots
etc.
Box Cox
2 people:Stella, Vasili


Regress given covariate (original model given by article)

```{r}
summary(lm(hate_crimes_per_100k_splc ~ . - state - hate_crimes_log, data = hate_crimes_df))
```

Yes, it does seem that the Gini index (income inequality) is the most significant predictor of hate crime and percent population with a HS degree is the only other significant predictor. Both of these results agree with the article.


```{r}
summary(lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc, data = hate_crimes_df))
```

Here we re-ran the same model, but using log of the output. We obtain the same results in terms of sigificant variables. 

### Put modeling results for just gini index as variable and log hate crimes as outcome

Lets do research to pick other covariates to include in our model

Variables shown to be statistically significant in existent literature: 

- Race, religion, sexual orientation - Source: Study of Literature And Legislation on Hate Crime in America (147 page report for the US Justice Department) (https://www.ncjrs.gov/pdffiles1/nij/grants/210300.pdf)
- Urbanization/population density, economic considerations (median income, poverty level, job availability), cultural and education factors - Source: US FBI website (https://ucr.fbi.gov/hate-crime/2011/resources/variables-affecting-crime)

Can also do a backwards stepwise selection to come up with a preliminary model and then add/subtract from that too

```{r model_stuff, message = FALSE, warning = FALSE}
hate_crimes_df = hate_crimes_df %>%
  drop_na()

# backwards selection

mult.fit <- lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc, data = hate_crimes_df)
step(mult.fit, direction = 'backward')

## backwards selection found only gini index and hs education to be significant
bw_mod = lm(formula = hate_crimes_log ~ perc_pop_hs + gini_index, 
    data = hate_crimes_df)
summary(bw_mod)

##backwards selection pre-excluding pop hs...does it include median income???
mult.fit.2 <- lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc -perc_pop_hs, data = hate_crimes_df)
step(mult.fit.2, direction = 'backward')

bw_mod_no_hs = lm(formula = hate_crimes_log ~ median_household_income + gini_index, 
    data = hate_crimes_df)
summary(bw_mod_no_hs)

summary(lm(formula = hate_crimes_log ~ median_household_income +perc_pop_hs + gini_index, 
    data = hate_crimes_df))

# forward selection

mult.fit <- lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc, data = hate_crimes_df)
step(mult.fit, direction = 'forward')

## forward selection found urbanization, unemployment, income, percent hs education, percent non-citizen, percent non-white and gini index to be significant
fw_mod = lm(formula = hate_crimes_log ~ perc_pop_hs + gini_index + unemployment + urbanization + median_household_income + perc_non_citizen + perc_non_white, data = hate_crimes_df)
summary(fw_mod)



perc_race1 = lm(formula = hate_crimes_log ~ perc_pop_hs + gini_index + perc_non_white + perc_non_citizen, 
    data = hate_crimes_df)
summary(perc_race1)

perc_race2 = lm(formula = hate_crimes_log ~ perc_pop_hs + gini_index + perc_non_citizen, 
    data = hate_crimes_df)
summary(perc_race2)

perc_race3 = lm(formula = hate_crimes_log ~ perc_pop_hs + gini_index + perc_non_white, 
    data = hate_crimes_df)
summary(perc_race3)



# Printing the 2 best models of each size, using the Cp criterion:
hc = hate_crimes_df %>%
  drop_na() %>%
  dplyr::select(-hate_crimes_per_100k_splc, -state) %>%
  mutate(unemployment = as.numeric(unemployment),
         urbanization = as.numeric(urbanization))

leaps::leaps(x = hc[,1:7], y = hc[,8], nbest=2, method="Cp")

# Printing the 2 best models of each size, using the adjusted R squared criterion:

leaps::leaps(x = hc[,1:7], y = hc[,8], nbest=2, method="adjr2")

b <- regsubsets(hate_crimes_log ~ ., data=hc)
rs <- summary(b)
rs

par(mar=c(4,4,1,1))
par(mfrow=c(1,2))

plot(2:8, rs$cp, xlab="No of parameters", ylab="Cp Statistic")
abline(0,1)

plot(2:8, rs$adjr2, xlab="No of parameters", ylab="Adj R2")



# Summary of models for each size (one model per size)
# Function regsubsets() performs a subset slection by identifying the "best" model that contains a certain number of predictors. By default "best" is chosen using SSE/RSS (smaller is better).


hc_1 = hate_crimes_df %>%
  drop_na() %>%
  dplyr::select(-hate_crimes_per_100k_splc, -state) %>%
  mutate(unemployment = as.numeric(unemployment),
         urbanization = as.numeric(urbanization))

b_1 <- leaps::regsubsets(hate_crimes_log ~ ., data=hc_1, nvmax = 7)
summary(b_1)

res.sum_1 <- summary(b_1)
data.frame(
  Adj.R2 = which.max(res.sum_1$adjr2),
  CP = which.min(res.sum_1$cp),
  BIC = which.min(res.sum_1$bic)
)

final_model <- lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = hate_crimes_df )
summary(final_model)

final_model_unemploy <- lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = hate_crimes_df)
summary(final_model_unemploy)

anova(final_model, final_model_unemploy)

par(mfrow = c(2,2))
plot(final_model)
plot(final_model_unemploy)

```

```{r interactions}
full_mod = lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc + unemployment*perc_pop_hs + unemployment*median_household_income + unemployment*perc_non_citizen + unemployment*gini_index + unemployment*perc_non_white + urbanization*perc_pop_hs + urbanization*median_household_income + urbanization*perc_non_citizen + urbanization*gini_index + urbanization*perc_non_white, data = hate_crimes_df)

summary(full_mod)

full_mod_1 = lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc + unemployment*perc_pop_hs + unemployment*perc_non_citizen + unemployment*gini_index + unemployment*perc_non_white + urbanization*perc_pop_hs + urbanization*perc_non_citizen + urbanization*gini_index + urbanization*perc_non_white, data = hate_crimes_df)

summary(full_mod_1)

small_mod = lm(hate_crimes_log ~ gini_index + perc_pop_hs + gini_index*unemployment + perc_pop_hs*unemployment, data = hate_crimes_df)

summary(small_mod)

small_mod_1 = lm(hate_crimes_log ~ gini_index + perc_pop_hs + gini_index*urbanization + perc_pop_hs*urbanization, data = hate_crimes_df)

summary(small_mod_1)
```
There shows to be no significant interactions between either of the categorical variables and the continuous variables. Nor did removing median_household_income (because of multicollinearity) show any significant interactions. There also shows to be no interactions between either of the categorical variables and gini_index and perc_pop_hs in the smaller models. 

```{r DC code}
hate_crimes_df_no_DC <- hate_crimes_df %>%
  filter(state != "District of Columbia")

full_mod = lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc + unemployment*perc_pop_hs + unemployment*median_household_income + unemployment*perc_non_citizen + unemployment*gini_index + unemployment*perc_non_white + urbanization*perc_pop_hs + urbanization*median_household_income + urbanization*perc_non_citizen + urbanization*gini_index + urbanization*perc_non_white, data = hate_crimes_df_no_DC)

summary(full_mod)

full_mod_1 = lm(hate_crimes_log ~ . - state - hate_crimes_per_100k_splc + unemployment*perc_pop_hs + unemployment*perc_non_citizen + unemployment*gini_index + unemployment*perc_non_white + urbanization*perc_pop_hs + urbanization*perc_non_citizen + urbanization*gini_index + urbanization*perc_non_white, data = hate_crimes_df_no_DC)

summary(full_mod_1)

small_mod = lm(hate_crimes_log ~ gini_index + perc_pop_hs + gini_index*unemployment + perc_pop_hs*unemployment, data = hate_crimes_df_no_DC)

summary(small_mod)

small_mod_1 = lm(hate_crimes_log ~ gini_index + perc_pop_hs + gini_index*urbanization + perc_pop_hs*urbanization, data = hate_crimes_df_no_DC)

summary(small_mod_1)


hc = hate_crimes_df_no_DC %>%
  drop_na() %>%
  dplyr::select(-hate_crimes_per_100k_splc, -state) %>%
  mutate(unemployment = as.numeric(unemployment),
         urbanization = as.numeric(urbanization))

leaps::leaps(x = hc[,1:7], y = hc[,8], nbest=2, method="Cp")

# Printing the 2 best models of each size, using the adjusted R squared criterion:

leaps::leaps(x = hc[,1:7], y = hc[,8], nbest=2, method="adjr2")

b <- regsubsets(hate_crimes_log ~ ., data=hc)
rs <- summary(b)
rs

par(mar=c(4,4,1,1))
par(mfrow=c(1,2))

plot(2:8, rs$cp, xlab="No of parameters", ylab="Cp Statistic")
abline(0,1)

plot(2:8, rs$adjr2, xlab="No of parameters", ylab="Adj R2")

res.sum_1 <- summary(b_1)
data.frame(
  Adj.R2 = which.max(res.sum_1$adjr2),
  CP = which.min(res.sum_1$cp),
  BIC = which.min(res.sum_1$bic)
)


final_model_no_DC <- lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = hate_crimes_df_no_DC )
summary(final_model_no_DC)

final_model_no_DC_unemploy <- lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = hate_crimes_df_no_DC)
summary(final_model_no_DC_unemploy)

anova(final_model_no_DC, final_model_no_DC_unemploy)

par(mfrow = c(2,2))
plot(final_model_no_DC)
plot(final_model_no_DC_unemploy)

```


Article supports percent non-white as an important variable (for college campuses): https://journals-sagepub-com.proxy.lib.umich.edu/doi/full/10.1177/1043986214536666?utm_source=summon&utm_medium=discovery-provider

Anti-hispanic and religious hate crimes on the rise: https://apnews.com/article/hate-crimes-rise-fbi-data-ebbcadca8458aba96575da905650120d

Make the association matrix and compare covariates-look for multicollinearity
3 people: Lily, Caroline, Tessa

Correlation matrix of all numeric variables with each other:

```{r cor mat}
hate_crimes_df %>% 
  drop_na(perc_non_citizen) %>%
  dplyr::select(!(state:urbanization)) %>% 
  cor() %>% 
  round(.,3) %>% knitr::kable()

library(car)

vif(lm(hate_crimes_log ~. - hate_crimes_per_100k_splc - state, data=hate_crimes_df)) %>%
  round(.,3) %>%
  knitr::kable() 
```

Out of the continuous variables, percent non-citizen and percent non-white has a correlation coefficient of 0.753, median household income and percentage of population with a HS degree has a correlation coefficient of 0.651, both of which may suggest multi-collinearity. All other variables do not suggest multi-collinearity.

Calculate VIFs for multicollinearity

Drop either perc non citizen or per non white
Drop either median household income or perc pop with HS degree-drop median household income due to multicollinearity

Test a model with interactions between each of the categorical variables and all the continuous variables-(pre-eliminate some continuous variables based on previous analysis).  Interaction between each categorical variable and the perc non white and perc non citizen

Interaction graphs of unemployment with all continuous variables to help with testing interactions:

```{r}
hate_crimes_df %>% pivot_longer(median_household_income:perc_non_white, names_to = "cont_var", values_to = "value") %>%  ggplot(aes(x = value, y = hate_crimes_log, color = unemployment)) + geom_point() + geom_smooth(method='lm', se=FALSE) + facet_wrap(~cont_var, scales = "free_x") 
```

Interaction graphs of urbanization with all continuous variables:

```{r}
hate_crimes_df %>% 
  pivot_longer(median_household_income:perc_non_white, names_to = "cont_var", values_to = "value") %>%  
  ggplot(aes(x = value, y = hate_crimes_log, color = urbanization)) +
  geom_point() + 
  geom_smooth(method='lm', se=FALSE) + 
  facet_wrap(~cont_var, scales = "free_x") 
```


```{r validate the model no DC}
library(caret)


final_model_no_DC <- lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = hate_crimes_df_no_DC )
summary(final_model_no_DC)

set.seed(1)
data_train<-trainControl(method="cv", number=5)


model_caret<-train(hate_crimes_log ~ gini_index + perc_pop_hs,
                   data=hate_crimes_df_no_DC,
                   trControl=data_train,
                   method='lm',
                   na.action=na.pass)
  

model_caret



model_caret$finalModel


model_caret$resample

sd(model_caret$resample$Rsquared)

##############################################
final_model_no_DC_unemploy <- lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = hate_crimes_df_no_DC)
summary(final_model_no_DC_unemploy)
set.seed(1)
data_train<-trainControl(method="cv", number=5)


model_caret<-train(hate_crimes_log ~ gini_index + perc_pop_hs +unemployment,
                   data=hate_crimes_df_no_DC,
                   trControl=data_train,
                   method='lm',
                   na.action=na.pass)
  

model_caret


model_caret$finalModel


model_caret$resample

sd(model_caret$resample$Rsquared)
```

```{r validate the model with DC}
library(caret)


final_model <- lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = hate_crimes_df)
summary(final_model)

set.seed(1)
data_train<-trainControl(method="cv", number=5)


model_caret<-train(hate_crimes_log ~ gini_index + perc_pop_hs,
                   data=hate_crimes_df,
                   trControl=data_train,
                   method='lm',
                   na.action=na.pass)
  
 
model_caret




model_caret$finalModel


model_caret$resample


sd(model_caret$resample$Rsquared)



final_model_unemploy <- lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = hate_crimes_df)
summary(final_model_unemploy)
set.seed(1)
data_train<-trainControl(method="cv", number=5)


model_caret<-train(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment,
                   data=hate_crimes_df,
                   trControl=data_train,
                   method='lm',
                   na.action=na.pass)
  

model_caret


model_caret$finalModel

model_caret$resample


sd(model_caret$resample$Rsquared)
```

























```{r more model validation no DC}
library(modelr)
set.seed(1)
final_model_no_DC <- lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = hate_crimes_df_no_DC )
#summary(final_model_no_DC)

final_model_no_DC_unemploy <- lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = hate_crimes_df_no_DC)
#summary(final_model_no_DC_unemploy)

cv_df =
  crossv_mc(hate_crimes_df_no_DC, 100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))

cv_df = 
  cv_df %>% 
  mutate(
    two_cov_model = map(train, ~lm(hate_crimes_log ~ gini_index + perc_pop_hs, data = .x)),
    three_cov_model = map(train, ~lm(hate_crimes_log ~ gini_index + perc_pop_hs + unemployment, data = .x))
  ) %>%
    
  mutate(
    rmse_two_cov = map2_dbl(two_cov_model, test, ~rmse(model = .x, data = .y)),
    rmse_three_cov = map2_dbl(three_cov_model, test, ~rmse(model = .x, data = .y))
    )

cv_df %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin() + 
  labs(
    title = "RMSE for Each of the Two Models",
    x = "Model",
    y = "RMSE"
  )
```




Stratify based on significant interactions and comment

Model diagnostics

Duplicate code with and without DC and comment on the effect of the outlier.

Final writeup!








